# 普通的插槽
	1.在父组件进行vnode创建过程中，对于组件会创建一个组件的占位vnode,然后把组件内的vnode数组作为该占位vnode的componentOptions属性的children属性保存，则componentOptions.children保存着组件插槽中的vnode数组。
	2.在子组件的_init过程中，会进行子组件选项的合并时，在子组件实例vm上定义_renderChildren属性指向componentOptions.children，即子组件vm._renderChildren属性保存着子组件的插槽内容(vnode数组)。
	3.在子组件的_init过程中进行initRender时，会进行插槽内容的解析，即定义$slots属性来保存不同命名slot对应的vnode。如vm.$slots.default = [vnode](默认插槽的vnode数组)。
	4.对于子组件模板中的slot标签，在模板解析和生成render函数代码时，对于该标签，会定义一个函数，在函数中会根据slot标签的命名，然后获取vm.$slots上对应的vnode数组返回。
	5.在子组件render时，对于slot标签，会生成他对于的插槽vnode，所以在patch阶段生成的dom是对于的插槽中的内容的dom。

	总结：子组件插槽中的vnode是在父组件render阶段生成的，然后在子组件render时，直接获取父组件相应的插槽的vnode，然后patch成dom。

# keep-alive组件
	1.keep-alive组件是一个抽闲的组件。在他的render中，会获取它的defult的slot(即它包裹的组件的vnode)，
	然后根据设置的include，exculde规则对匹配到的包裹组件的vnode进行缓存。
	2.当父组件更新时，对于keep-alive组件会进行强制的更新，即执行它的render函数。
	3.对于keep-alive包裹的组件的首次渲染是相同的，只是会在keep-alive中缓存它的vnode和渲染的结果。
	4.keep-alive组件进行重新render时，会根据匹配的规则返回已经缓存过的组件vnode，所以对于keep-alive包裹的组件再次激活时，在创建组件的时候，只是会更新组件的vnode,listeners等状态，然后使用之前的vnode.elm插入父节点中，并且执行activated钩子函数，并不会进行$mount的操作，即不会进行重新render。
	5.keep-alive包裹的组件的销毁并不会调用$destory来销毁组件，只是会执行组件的deactivated钩子函数。
	